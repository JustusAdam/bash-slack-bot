{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE UnicodeSyntax     #-}


import           Control.Applicative
import           Control.Applicative.Unicode
import           Control.Monad
import           Control.Monad.IO.Class
import           Control.Monad.Unicode
import           Data.ByteString.Char8       as C hiding (putStrLn, unlines)
import           Data.Char
import           Data.Maybe
import           Data.Monoid
import           Data.Monoid.Unicode
import           Data.Text.Lazy              as T hiding (unpack)
import           Data.Text.Lazy.Encoding
import           Data.Yaml
import Data.Function
import           Network.Browser
import           Network.HTTP                hiding (password, port)
import           Network.HTTP.Auth
import           Network.HTTP.Types          hiding (POST)
import           Network.URI
import           Network.Wai
import           Network.Wai.Handler.Warp
import           Network.Wai.Parse
import           Prelude.Unicode
import           System.Environment
import           Text.Printf
import System.Eval.Haskell


a & b = b a


commands ‚à∑ [(ByteString, AppSettings ‚Üí HookData ‚Üí IO Text)]
commands =
  [ ("bashthis:", addNew)
  , ("evaluate:", evaluateCode)
  ]


data HookData = HookData { hookDataToken ‚à∑ ByteString
                         , command       ‚à∑ ByteString
                         , text          ‚à∑ ByteString
                         } deriving (Show)


data AppSettings = AppSettings { port             ‚à∑ Int
                               , appSettingsToken ‚à∑ Maybe ByteString
                               , password         ‚à∑ String
                               , username         ‚à∑ String
                               , uri              ‚à∑ URI
                               , minQuoteLength   ‚à∑ Maybe Int
                               , logfile          ‚à∑ Maybe FilePath
                               } deriving (Show)


truncateCommand command = C.dropWhile isSpace . C.drop (C.length command)


evaluateHaskell ‚à∑ String ‚Üí IO String
evaluateHaskell code = do
  evaluated <- unsafeEval ("show $ " ‚äï code) ["Prelude"]
  return $ fromMaybe "Evaluation failed" evaluated


evaluableLanguages =
  [ ("hs", evaluateHaskell)
  , ("haskell", evaluateHaskell)
  ]


writeLog ‚à∑ AppSettings ‚Üí String ‚Üí IO ()
writeLog (AppSettings { logfile = (Just f) }) =
  Prelude.appendFile f
writeLog _ = const $ return ()


showLog ‚à∑ Show s ‚áí AppSettings ‚Üí s ‚Üí IO ()
showLog set = writeLog set ‚àò show


addNew ‚à∑ AppSettings ‚Üí HookData ‚Üí IO Text
addNew
  settings@(AppSettings { username = user, password = passwd, uri = uri, minQuoteLength = mql })
  (HookData { command = cmd, text = text })
  = if lengthVerifier quote
    then browse $ do
      setAuthorityGen (\_ _ ‚Üí return $ return (user, passwd))
      setAllowBasicAuth True
      request req
      liftIO $ writeLog settings "success"
      return "Yeey, new quotes!!! Thank you üòÉ"
    else
      return $ "Your quote is too short, the bash will reject it üòê. "
        ‚äï maybe "" (\req -> "Just make it like at least " ‚äï T.pack (show (req - C.length quote)) ‚äï " characters longer.") mql
    where
      quote = truncateCommand cmd text
      lengthVerifier = maybe (const True) (\a b -> a ‚â§ C.length b) mql
      req = formToRequest body
      -- authority = AuthBasic { auRealm = realm, auUsername = user, auPassword = passwd, auSite = uri }
      body =
        Form
          POST
          uri
          [ ("rash_quote", unpack quote)
          , ("submit", "Add Quote")
          ]


evaluateCode
  _
  (HookData { command = cmd, text = text })
  =
    let
      truncated = truncateCommand cmd text
    in
      case C.words truncated of
        t@(lang:_) ->
          let
            code = truncateCommand lang truncated
          in
            maybe (return "Unknown Language") (fmap (wrapCode . T.pack) . (C.unpack code &)) $ lookup lang evaluableLanguages
        _ -> return "You need provide a language"
    where
      wrapCode c = "`" <> c <> "`"


instance FromJSON AppSettings where
  parseJSON (Object o) = AppSettings
    <$> o .: "port"
    ‚äõ (fmap $ fmap C.pack) (o .:? "token")
    ‚äõ o .: "password"
    ‚äõ o .: "username"
    ‚äõ fmap (fromJust ‚àò parseURI) (o .: "target")
    ‚äõ o .:? "min_quote_length"
    ‚äõ o .:? "logfile"


parseData ‚à∑ [(ByteString, ByteString)] ‚Üí Maybe HookData
parseData params = HookData
  <$> lookup "token" params
  ‚äõ lookup "trigger_word" params
  ‚äõ lookup "text" params


app ‚à∑ AppSettings ‚Üí Application
app settings@(AppSettings { appSettingsToken = expectedToken }) req respond = do
  mpostData ‚Üê parseData ‚àò fst <$> parseRequestBody lbsBackEnd req

  case mpostData of
    Nothing ‚Üí respondFail
    Just postData@(HookData { hookDataToken = token, command = command, text = text }) ‚Üí
      if verifier token
        then
          case lookup command commands of
            Nothing ‚Üí respondFail
            Just action ‚Üí do
              showLog settings postData
              action settings postData ‚â´= respondSuccess
        else respondFail

  where
    verifier = maybe (const True) (‚â°) expectedToken
    respondSuccess message =
      respond $ responseLBS status200 [("Content-Type", "application/json")] $ encodeUtf8 $ "{\"text\":\"" ‚äï message ‚äï "\"}"
    respondFail =
      respond $ responseLBS badRequest400 [] $ encodeUtf8 "{\"text\": \"Sorry, something went wrong üòê\"}"


main ‚à∑ IO ()
main = do
  [settingsFile] ‚Üê getArgs
  sf ‚Üê decodeFile settingsFile
  case sf of
    Nothing ‚Üí putStrLn "could not read settings"
    Just conf ‚Üí do
      writeLog conf "Starting server with config:"
      showLog conf conf
      run (port conf) (app conf)
